# app.py

# ==============================================
# å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
# ==============================================
import streamlit as st
import cv2
import numpy as np
import av
import plotly.graph_objects as go
import pandas as pd
from streamlit_webrtc import webrtc_streamer, WebRtcMode, RTCConfiguration
import tempfile
import os
import time
from typing import List, Tuple


# ==============================================
# ãƒšãƒ¼ã‚¸ã®åŸºæœ¬è¨­å®š
# ==============================================
st.set_page_config(
    page_title="å‹•ç”»è»Œé“è¿½è·¡ã‚¢ãƒ—ãƒª",
    page_icon="ğŸ¥",
    layout="wide"
)

st.title("ğŸ¥ å‹•ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ â†’ å€é€Ÿ â†’ è»Œé“è¿½è·¡ã‚¢ãƒ—ãƒª")
st.write("""
1. å‹•ç”»ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
2. è‡ªå‹•ã§**2å€é€Ÿ**ã«å¤‰æ›
3. **1ã¤ã®ç‰©ä½“**ã®å‹•ãã‚’**è‡ªå‹•æ¤œå‡ºãƒ»è¿½è·¡**
4. **è»Œé“ã‚’èµ¤ã„ç·šã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º**
""")


# ==============================================
# ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®åˆæœŸåŒ–
# ==============================================
if "trajectory_x" not in st.session_state:
    st.session_state.trajectory_x = []
if "trajectory_y" not in st.session_state:
    st.session_state.trajectory_y = []
if "processed_video" not in st.session_state:
    st.session_state.processed_video = None
if "frame_timestamps" not in st.session_state:
    st.session_state.frame_timestamps = []


# ==============================================
# å‹•ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨å€é€Ÿå‡¦ç†
# ==============================================
st.subheader("1. ğŸ“‚ å‹•ç”»ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆè‡ªå‹•2å€é€Ÿå¤‰æ›ï¼‰")

uploaded_file = st.file_uploader(
    "å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠï¼ˆMP4, AVI, MOVãªã©ï¼‰",
    type=['mp4', 'avi', 'mov', 'mkv', 'webm'],
    help="ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¾Œã€è‡ªå‹•ã§2å€é€Ÿã«å¤‰æ›ã•ã‚Œã¾ã™"
)

if uploaded_file is not None:
    # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    tfile = tempfile.NamedTemporaryFile(delete=False, suffix=".mp4")
    tfile.write(uploaded_file.read())
    tfile_path = tfile.name
    tfile.close()
    
    with st.spinner("å‹•ç”»ã‚’2å€é€Ÿã«å¤‰æ›ä¸­...ï¼ˆåˆå›ã®ã¿æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ï¼‰"):
        # å€é€Ÿå¤‰æ›å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        processed_path = tfile_path.replace(".mp4", "_2x.mp4")
        
        # FFmpegã‚³ãƒãƒ³ãƒ‰ã§2å€é€Ÿå¤‰æ›ï¼ˆéŸ³å£°ã‚‚åŒæœŸï¼‰
        cmd = [
            "ffmpeg", "-y", "-i", tfile_path,
            "-filter_complex", "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]",
            "-map", "[v]", "-map", "[a]",
            "-c:v", "libx264", "-preset", "ultrafast",
            processed_path, "-loglevel", "quiet"
        ]
        
        import subprocess
        result = subprocess.run(cmd, capture_output=True)
        
        if result.returncode == 0:
            st.session_state.processed_video = processed_path
            st.success("âœ… 2å€é€Ÿå¤‰æ›å®Œäº†ï¼")
            st.info(f"å¤‰æ›å¾Œãƒ•ã‚¡ã‚¤ãƒ«: {os.path.basename(processed_path)}")
        else:
            st.error("å‹•ç”»å¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸã€‚MP4å½¢å¼ã‚’æ¨å¥¨ã—ã¾ã™ã€‚")
    
    # å…ƒãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
    os.unlink(tfile_path)


# ==============================================
# ç‰©ä½“è¿½è·¡å‡¦ç†
# ==============================================
def detect_and_track(frame: np.ndarray, prev_center: Tuple[int, int] = None) -> Tuple[int, int]:
    """
    ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§å‹•ãç‰©ä½“ã‚’æ¤œå‡ºã—ã€ãã®ä¸­å¿ƒåº§æ¨™ã‚’è¿”ã™
    """
    # ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # å‰å›ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã®å·®åˆ†ã§å‹•ãã‚’æ¤œå‡º
    if prev_center:
        # å‰å›ä¸­å¿ƒä»˜è¿‘ã®ROIï¼ˆé–¢å¿ƒé ˜åŸŸï¼‰ã‚’æ‹¡å¤§è¡¨ç¤º
        h, w = frame.shape[:2]
        roi_size = 100
        cx, cy = prev_center
        x1 = max(0, cx - roi_size//2)
        y1 = max(0, cy - roi_size//2)
        x2 = min(w, cx + roi_size//2)
        y2 = min(h, cy + roi_size//2)
        
        roi = gray[y1:y2, x1:x2]
        
        # ROIå†…ã§æ˜ã‚‹ã•å¤‰åŒ–ã®å¤§ãã„ç‚¹ã‚’æ¢ã™
        diff = cv2.absdiff(gray, cv2.GaussianBlur(gray, (21, 21), 0))
        thresh = cv2.threshold(diff, 30, 255, cv2.THRESH_BINARY)[1]
        
        # è¼ªéƒ­æ¤œå‡º
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        if contours:
            # ä¸€ç•ªå¤§ãã„è¼ªéƒ­ï¼ˆå‹•ã„ã¦ã„ã‚‹ç‰©ä½“ï¼‰ã‚’é¸æŠ
            largest_contour = max(contours, key=cv2.contourArea)
            if cv2.contourArea(largest_contour) > 100:
                M = cv2.moments(largest_contour)
                if M["m00"] != 0:
                    new_cx = int(M["m10"] / M["m00"]) + x1
                    new_cy = int(M["m01"] / M["m00"]) + y1
                    return (new_cx, new_cy)
    
    # åˆå›æ¤œå‡ºï¼šç”»é¢ä¸­å¤®ä»˜è¿‘ã®å‹•ãã‚’æ¤œå‡º
    blur = cv2.GaussianBlur(gray, (21, 21), 0)
    diff = cv2.absdiff(gray, blur)
    thresh = cv2.threshold(diff, 25, 255, cv2.THRESH_BINARY)[1]
    
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        if cv2.contourArea(largest_contour) > 200:
            M = cv2.moments(largest_contour)
            if M["m00"] != 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                return (cx, cy)
    
    # æ¤œå‡ºå¤±æ•—æ™‚ã¯å‰å›ä½ç½®ã‚’è¿”ã™
    return prev_center or (320, 240)


# ==============================================
# å‹•ç”»å†ç”Ÿï¼†è¿½è·¡å®Ÿè¡Œ
# ==============================================
if st.session_state.processed_video:
    st.subheader("2. â–¶ï¸ å€é€Ÿå‹•ç”»å†ç”Ÿï¼†è‡ªå‹•è»Œé“è¿½è·¡")
    
    col1, col2 = st.columns([3, 1])
    
    with col2:
        # è¿½è·¡æ„Ÿåº¦èª¿æ•´
        sensitivity = st.slider("è¿½è·¡æ„Ÿåº¦", 1, 100, 30)
        speed_factor = st.slider("å†ç”Ÿé€Ÿåº¦", 0.5, 3.0, 1.0)
    
    with col1:
        # å‹•ç”»å†ç”Ÿç”¨ã®ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
        class VideoProcessor:
            def __init__(self):
                self.prev_center = None
                self.frame_count = 0
                
            def recv(self, frame):
                img = frame.to_ndarray(format="bgr24")
                
                # è¿½è·¡å®Ÿè¡Œ
                center = detect_and_track(img, self.prev_center)
                if center:
                    self.prev_center = center
                    # ç”»é¢ä¸­å¿ƒã‹ã‚‰ã®æ­£è¦åŒ–åº§æ¨™ã«å¤‰æ›
                    h, w = img.shape[:2]
                    norm_x = (center[0] - w//2) / (w//2)
                    norm_y = (center[1] - h//2) / (h//2)
                    
                    st.session_state.trajectory_x.append(norm_x)
                    st.session_state.trajectory_y.append(norm_y)
                    st.session_state.frame_timestamps.append(self.frame_count)
                
                self.frame_count += 1
                
                # è¿½è·¡ç‚¹ã‚’ç·‘ã®å††ã§è¡¨ç¤º
                if self.prev_center:
                    cv2.circle(img, self.prev_center, 10, (0, 255, 0), 3)
                
                return av.VideoFrame.from_ndarray(img, format="bgr24")
        
        # WebRTCã§å‹•ç”»å†ç”Ÿï¼ˆç°¡æ˜“ç‰ˆï¼‰
        ctx = webrtc_streamer(
            key="tracker",
            mode=WebRtcMode.SENDONLY,
            video_processor_factory=VideoProcessor,
            rtc_configuration=RTCConfiguration({"iceServers": [{"urls": ["stun:stun.l.google.com:19302"]}]})
        )


# ==============================================
# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è»Œé“è¡¨ç¤º
# ==============================================
st.subheader("3. ğŸ“ˆ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è»Œé“ã‚°ãƒ©ãƒ•")

if len(st.session_state.trajectory_x) > 1:
    fig = go.Figure()
    
    # è»Œè·¡ãƒ—ãƒ­ãƒƒãƒˆ
    fig.add_trace(go.Scatter(
        x=st.session_state.trajectory_x[-200:],
        y=st.session_state.trajectory_y[-200:],
        mode='lines+markers',
        line=dict(color='red', width=4),
        marker=dict(size=6, color='darkred'),
        name='è»Œé“'
    ))
    
    # ç¾åœ¨ä½ç½®
    if st.session_state.trajectory_x:
        fig.add_trace(go.Scatter(
            x=[st.session_state.trajectory_x[-1]],
            y=[st.session_state.trajectory_y[-1]],
            mode='markers',
            marker=dict(size=12, color='yellow', symbol='star'),
            name='ç¾åœ¨ä½ç½®'
        ))
    
    fig.update_layout(
        title="ç‰©ä½“è¿½è·¡è»Œé“ï¼ˆèµ¤ç·šï¼‰",
        xaxis_title="Xä½ç½®ï¼ˆæ­£è¦åŒ–ï¼‰",
        yaxis_title="Yä½ç½®ï¼ˆæ­£è¦åŒ–ï¼‰",
        template='plotly_dark',
        height=500
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # çµ±è¨ˆæƒ…å ±
    st.metric("è¿½è·¡ç‚¹æ•°", len(st.session_state.trajectory_x))
    if len(st.session_state.trajectory_x) > 1:
        speeds = np.sqrt(np.diff(st.session_state.trajectory_x)**2 + np.diff(st.session_state.trajectory_y)**2)
        st.metric("å¹³å‡é€Ÿåº¦", f"{np.mean(speeds):.3f}")


# ==============================================
# ãƒ‡ãƒ¼ã‚¿ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
# ==============================================
if st.session_state.trajectory_x:
    st.subheader("4. ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ä¿å­˜")
    
    df = pd.DataFrame({
        'ãƒ•ãƒ¬ãƒ¼ãƒ ç•ªå·': st.session_state.frame_timestamps,
        'Xåº§æ¨™': st.session_state.trajectory_x,
        'Yåº§æ¨™': st.session_state.trajectory_y
    })
    
    csv = df.to_csv(index=False).encode('utf-8-sig')
    st.download_button(
        "ğŸ“¥ CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
        csv,
        "trajectory_data.csv",
        "text/csv"
    )


# ==============================================
# ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
# ==============================================
st.subheader("ğŸ”„ ãƒªã‚»ãƒƒãƒˆ")
if st.button("ğŸ—‘ï¸ è»Œè·¡ã‚¯ãƒªã‚¢", type="secondary"):
    st.session_state.trajectory_x = []
    st.session_state.trajectory_y = []
    st.session_state.frame_timestamps = []
    st.rerun()


# ==============================================
# ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ‰‹é †
# ==============================================
with st.expander("âš™ï¸ å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆåˆå›ã®ã¿ï¼‰"):
    st.code("""
pip install streamlit opencv-python av streamlit-webrtc plotly pandas numpy
# FFmpegã‚‚å¿…è¦ï¼ˆè‡ªå‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œãªã„å ´åˆï¼‰
# Windows: https://ffmpeg.org/download.html
# macOS: brew install ffmpeg
# Ubuntu: sudo apt install ffmpeg
""")
